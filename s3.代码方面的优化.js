/*
    代码方面的优化
*/

1.javascript常用的代码优化方案:
减少js代码体积问题:
(1).Code splitting 代码分割,按需加载
(2).tree shaking 去掉一些没有用到的代码
减少主线程工作量:
(1).避免长任务，长时间的阻塞主线程，
(2). 避免超过1KB的行间脚本,就是将代码直接写在html中让js代码直接加载执行，这是一中优化策略，例如可用于首屏渲染
(3).使用raf和ric进行时间调度，例如React Fiber的实现原理

2.函数优化:
函数的解析方式:
lazy parsing(懒解析) ：也就是当真正执行到函数体的时候才会去解析函数，这样做的好处是省去函数构建等一系列步骤，
可以在大部分情况下性能得到优化，这也是默认解析方式
eager parsing(饥饿解析):当碰到函数的时候 就会立即解析，
怎么将懒解析变成饥饿解析了呢？
很简单，在需要将懒解析变成饥饿解析的函数只需要在外层包一层括号就可以，例如:(function(){})
但是这里存在一个坑，在webpack4.0以下，它的压缩会将我们期待的括号给去掉，因此需要Optimize.js这个库处理
在webpack4.0以上则已经修复了这个bug了

3.对象的优化：
(1).对象的初始化顺序要一致，当初始化顺序一致的时候V8底层对隐藏类型(hidden class)可进行复用
反例：
const obj = { name:"huang" };//创建第一个隐藏类型hc1
obj.age = 20;//hc2

const obj2 = { age:20 };//hc3
obj2.age = 20;//hc4
好例:
const obj = {name:"huang"};//创建一个隐藏类型hc1
obj.age=20;//hc2

const obj2={name:"huang"};//复用隐藏类型hc1
obj.age=20;//hc2

(2).实例化后避免去增加属性:
反例：
const obj = { name:"huang" };
obj.age=18;
应该一次性的去初始化:
const obj ={
    name:"huang",
    age:20
}
(3).使用数组进行开发比类数组要效率高，
例如:
遍历一个类数组 效率要比 先把类数组转化为数组，再使用数组进行遍历低
(4).不建议访问比超过数组长度的值(数组越界)

(5).避免进行类型转换:
例如:
const arr = [1,2,3];
arr.push("string");

4.HTML的优化:
(1).减少使用iframes
(2).压缩空白符
(3).避免节点深层次嵌套(嵌套越多，生成DOM树的效率会越低)
(4).避免使用table布局
(5).删除注释
(6).CSS和JS尽量外链
(7).删除元素默认属性
5.CSS优化:
(1).降低CSS对渲染的阻塞
(2).利用GPU进行完成动画，使用will-change单独抽出一个图层
(3).contain:layout这个是最重要的优化属性，这个属性就是开发者和浏览器进行沟通的属性，
它告诉使用contain这个属性的元素，无论它怎么变化都跟盒子外面的没关系，也就是不会触发回流和重绘操作

